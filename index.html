<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>50/50 Silver & Green Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }

        .tab-content {
            display: none !important; 
            animation: fadeIn 0.3s ease-in-out;
        }
        .tab-content.active {
            display: flex !important;
            flex-direction: column;
            gap: 1.5rem; 
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #grid-style-options {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin 0.3s ease;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            margin-top: 0;
        }
        #grid-style-options.visible {
            max-height: 100px;
            opacity: 1;
            margin-top: 0.75rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center py-8 px-4 font-sans">

    <!-- Header -->
    <header class="text-center mb-8 max-w-2xl">
        <h1 class="text-3xl md:text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-gray-300 to-green-400">
            50/50 Generator
        </h1>
        <p class="text-gray-400 text-sm md:text-base">
            Mathematically precise: <span class="text-gray-200 font-bold">50% Silver</span>, <span class="text-green-400 font-bold">50% Green</span>.
        </p>
    </header>

    <!-- Navigation Tabs -->
    <div class="flex gap-4 mb-6 bg-gray-800 p-1 rounded-xl border border-gray-700">
        <button onclick="switchTab('dots')" id="tab-dots" class="px-6 py-2 rounded-lg font-bold text-sm transition-all bg-gray-700 text-white shadow-sm">
            Polka Dots
        </button>
        <button onclick="switchTab('splits')" id="tab-splits" class="px-6 py-2 rounded-lg font-bold text-sm transition-all text-gray-400 hover:text-white">
            Geometric Splits
        </button>
    </div>

    <!-- Main Card -->
    <main class="bg-gray-800 p-6 rounded-2xl shadow-2xl w-full max-w-5xl border border-gray-700 flex flex-col md:flex-row gap-8">
        
        <!-- CONTROLS COLUMN -->
        <div class="w-full md:w-1/3 flex flex-col gap-6">

            <!-- SHAPE CONTROL (Global) -->
            <div class="bg-gradient-to-br from-gray-700 to-gray-800 p-4 rounded-xl border border-gray-500 shadow-lg">
                <label class="block text-gray-200 text-xs font-bold uppercase tracking-wider mb-3 flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>
                    Canvas Shape
                </label>
                <div class="flex bg-gray-900 p-1 rounded-lg">
                    <button onclick="setShape('square')" id="btn-shape-square" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-white bg-gray-600 shadow-sm flex flex-col items-center leading-tight">
                        <span>Square</span>
                        <span class="text-[10px] opacity-70">5000x5000</span>
                    </button>
                    <button onclick="setShape('rect')" id="btn-shape-rect" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-gray-400 hover:text-white flex flex-col items-center leading-tight">
                        <span>Rectangle</span>
                        <span class="text-[10px] opacity-70">8500x5000</span>
                    </button>
                </div>
            </div>
            
            <!-- ============================== -->
            <!-- TAB 1 CONTENT: DOTS ONLY       -->
            <!-- ============================== -->
            <div id="controls-dots" class="tab-content active">
                
                <!-- Color Swap (Dots) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider mb-3">Colors</label>
                    <button onclick="toggleInvert('dots')" id="btn-invert-dots" class="w-full py-2 text-sm rounded-md transition-all font-medium text-white bg-gray-600 hover:bg-gray-500 shadow-sm flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 10v12"/><path d="M15 10.5a2.5 2.5 0 0 1 5 0 2.5 2.5 0 0 1-5 0Z"/><path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7"/><path d="M12 3v18"/></svg>
                        <span id="text-invert-dots">Green Dots (Silver BG)</span>
                    </button>
                </div>

                <!-- Layout Control (Dots) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider mb-3">Pattern Type</label>
                    <div class="flex bg-gray-900 p-1 rounded-lg">
                        <button onclick="setDotMode('layout', 'grid')" id="btn-grid" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-white bg-gray-700 shadow-sm">Grid</button>
                        <button onclick="setDotMode('layout', 'random')" id="btn-random" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-gray-400 hover:text-white">Bubbly</button>
                    </div>

                    <!-- Sub-options for Grid (Hidden by default) -->
                    <div id="grid-style-options">
                        <label class="block text-gray-400 text-[10px] font-bold uppercase tracking-wider mb-2">Grid Style</label>
                        <div class="flex bg-gray-900 p-1 rounded-lg">
                            <button onclick="setDotMode('gridStyle', 'aligned')" id="btn-grid-aligned" class="flex-1 py-1.5 text-xs rounded-md transition-all font-medium text-white bg-gray-700 shadow-sm">Aligned</button>
                            <button onclick="setDotMode('gridStyle', 'staggered')" id="btn-grid-staggered" class="flex-1 py-1.5 text-xs rounded-md transition-all font-medium text-gray-400 hover:text-white">Staggered</button>
                        </div>
                    </div>
                </div>

                <!-- Size Control (Dots) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider mb-3">Dot Sizes</label>
                    <div class="flex bg-gray-900 p-1 rounded-lg">
                        <button onclick="setDotMode('size', 'uniform')" id="btn-uniform" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-gray-400 hover:text-white">Same</button>
                        <button onclick="setDotMode('size', 'varied')" id="btn-varied" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-white bg-gray-700 shadow-sm">Varied</button>
                    </div>
                </div>

                <!-- Count Slider (Dots) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <div class="flex justify-between items-center mb-3">
                        <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider">Count</label>
                        <span id="count-display" class="text-green-400 font-mono text-sm bg-gray-900 px-2 py-1 rounded">100</span>
                    </div>
                    <input type="range" id="count-slider" min="10" max="200" value="100" step="1" oninput="updateCountDisplay(this.value)" onchange="generateImage()">
                </div>

                <!-- Spacing Slider (Dots) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <div class="flex justify-between items-center mb-3">
                        <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider">Regularity</label>
                        <span id="spacing-display" class="text-green-400 font-mono text-sm bg-gray-900 px-2 py-1 rounded">50%</span>
                    </div>
                    <input type="range" id="spacing-slider" min="0" max="100" value="50" step="10" oninput="updateSpacingDisplay(this.value)" onchange="generateImage()">
                </div>
            </div>

            <!-- ============================== -->
            <!-- TAB 2 CONTENT: SPLITS ONLY     -->
            <!-- ============================== -->
            <div id="controls-splits" class="tab-content">
                
                <!-- Color Swap (Splits) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider mb-3">Position</label>
                    <button onclick="toggleInvert('splits')" id="btn-invert-splits" class="w-full py-2 text-sm rounded-md transition-all font-medium text-white bg-gray-600 hover:bg-gray-500 shadow-sm flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>
                        <span id="text-invert-splits">Swap Colors</span>
                    </button>
                </div>

                <!-- Style Control (Splits) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider mb-3">Split Style</label>
                    <div class="flex flex-col gap-2 bg-gray-900 p-2 rounded-lg">
                        <button onclick="setSplitMode('style', 'linear')" id="btn-style-linear" class="w-full py-2 text-sm rounded-md transition-all font-medium text-white bg-gray-700 shadow-sm">Linear (Stripes)</button>
                        <button onclick="setSplitMode('style', 'diagonal')" id="btn-style-diagonal" class="w-full py-2 text-sm rounded-md transition-all font-medium text-gray-400 hover:text-white">Diagonal (Radial)</button>
                        <button onclick="setSplitMode('style', 'checker')" id="btn-style-checker" class="w-full py-2 text-sm rounded-md transition-all font-medium text-gray-400 hover:text-white">Checkerboard</button>
                    </div>
                </div>

                <!-- Orientation Control (Splits) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider mb-3">Orientation</label>
                    <div class="flex bg-gray-900 p-1 rounded-lg">
                        <button onclick="setSplitMode('orient', 'vert')" id="btn-orient-vert" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-white bg-gray-700 shadow-sm">Vert</button>
                        <button onclick="setSplitMode('orient', 'horz')" id="btn-orient-horz" class="flex-1 py-2 text-sm rounded-md transition-all font-medium text-gray-400 hover:text-white">Horz</button>
                    </div>
                    <p class="text-[10px] text-gray-500 mt-2 text-center italic">*Applies to all styles</p>
                </div>

                <!-- Divisions Control (Splits) -->
                <div class="bg-gray-700/50 p-4 rounded-xl border border-gray-600">
                    <label class="block text-gray-300 text-xs font-bold uppercase tracking-wider mb-3">Divisions</label>
                    <div class="grid grid-cols-4 gap-2">
                        <button onclick="setSplitMode('divisions', 2)" id="btn-div-2" class="py-2 rounded-lg bg-gray-700 text-white font-bold border border-green-500/50 shadow-[0_0_10px_rgba(74,222,128,0.2)]">2</button>
                        <button onclick="setSplitMode('divisions', 4)" id="btn-div-4" class="py-2 rounded-lg bg-gray-900 text-gray-400 font-bold hover:bg-gray-800">4</button>
                        <button onclick="setSplitMode('divisions', 8)" id="btn-div-8" class="py-2 rounded-lg bg-gray-900 text-gray-400 font-bold hover:bg-gray-800">8</button>
                        <button onclick="setSplitMode('divisions', 16)" id="btn-div-16" class="py-2 rounded-lg bg-gray-900 text-gray-400 font-bold hover:bg-gray-800">16</button>
                    </div>
                </div>
            </div>

            <!-- Common Action Buttons -->
            <div class="mt-auto flex flex-col gap-3">
                <button onclick="randomizeSettings()" class="w-full bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 text-white font-bold py-3 px-6 rounded-lg transition-all shadow-lg active:transform active:scale-95 flex items-center justify-center gap-2 mb-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>
                    Randomize Settings
                </button>
                
                <button onclick="generateImage()" id="genBtn" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-6 rounded-lg transition-all shadow-lg active:transform active:scale-95 flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>
                    Regenerate
                </button>
                <button onclick="downloadImage()" id="dlBtn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition-all shadow-lg active:transform active:scale-95 flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    Download
                </button>
            </div>
        </div>

        <!-- PREVIEW COLUMN -->
        <div class="w-full md:w-2/3 flex flex-col gap-6">
            
            <!-- Preview Container -->
            <div class="flex flex-col items-center justify-center bg-gray-900 rounded-xl border-2 border-gray-700 shadow-inner p-4 w-full">
                <div id="preview-container" class="relative shadow-2xl transition-all duration-300" style="width: 100%; aspect-ratio: 1/1;">
                    <canvas id="canvas" class="hidden"></canvas>
                    <img id="preview" src="" alt="Generated Pattern" class="w-full h-full object-contain opacity-0 transition-opacity duration-500 rounded-lg">
                    
                    <div id="loader" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-900/90 z-10 backdrop-blur-sm rounded-lg">
                        <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-green-500 mb-3"></div>
                        <p class="text-green-400 font-mono text-sm animate-pulse">Calculating Geometry...</p>
                    </div>

                    <!-- Stats Overlay -->
                    <div class="absolute bottom-3 right-3 bg-black/80 backdrop-blur px-3 py-2 rounded-lg text-xs border border-gray-600 shadow-lg pointer-events-none z-10">
                        <div class="flex items-center gap-2 mb-1">
                            <div class="w-2 h-2 rounded-full bg-[#C0C0C0]"></div> 
                            <span id="stat-silver" class="text-gray-300 font-mono">Silver: 50%</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-2 h-2 rounded-full bg-[#008000]"></div> 
                            <span id="stat-green" class="text-green-400 font-mono">Green: 50%</span>
                        </div>
                        <div class="mt-1 pt-1 border-t border-gray-600 text-gray-500 font-mono" id="res-display">
                            5000 x 5000
                        </div>
                    </div>
                </div>
            </div>

            <!-- Math Explanation Footer -->
            <div class="w-full bg-gray-800 rounded-xl border border-gray-700 p-5 shadow-lg">
                <h3 class="text-lg font-bold text-gray-300 mb-3 flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="16" y1="14" x2="16" y2="14"/><line x1="8" y1="14" x2="8" y2="14"/><line x1="12" y1="14" x2="12" y2="14"/><line x1="16" y1="18" x2="16" y2="18"/><line x1="8" y1="18" x2="8" y2="18"/><line x1="12" y1="18" x2="12" y2="18"/></svg>
                    How is this calculated?
                </h3>
                <div id="math-output" class="font-mono text-xs md:text-sm text-gray-400 space-y-2 leading-relaxed">
                    <!-- Dynamic Math Content -->
                </div>
            </div>

        </div>

    </main>

    <script>
        // --- CONSTANTS ---
        const COLOR_SILVER = "#C0C0C0";
        const COLOR_GREEN = "#008000";

        // --- STATE ---
        let state = {
            width: 5000,
            height: 5000,
            activeTab: 'dots', // 'dots' | 'splits'
            
            // Polka Dots State
            dots: {
                layout: 'grid',    // 'grid' | 'random'
                gridStyle: 'aligned', // 'aligned' | 'staggered'
                size: 'varied',
                count: 100,
                spacing: 50,
                invert: false // false = Green dots on Silver, true = Silver dots on Green
            },

            // Splits State
            splits: {
                style: 'linear', // 'linear' | 'diagonal' | 'checker'
                orient: 'vert',  // 'vert' | 'horz'
                divisions: 2,     // 2, 4, 8, 16
                invert: false    // Swaps colors (position)
            }
        };

        // --- DOM Elements ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const preview = document.getElementById('preview');
        const previewContainer = document.getElementById('preview-container');
        const loader = document.getElementById('loader');
        const dlBtn = document.getElementById('dlBtn');
        const genBtn = document.getElementById('genBtn');
        const resDisplay = document.getElementById('res-display');
        const statSilver = document.getElementById('stat-silver');
        const statGreen = document.getElementById('stat-green');
        const mathOutput = document.getElementById('math-output');

        // --- INITIALIZATION ---
        window.onload = function() {
            switchTab('dots');
            updateGridOptionsVisibility();
        };

        // --- SHAPE LOGIC ---
        function setShape(shape) {
            const btnSq = document.getElementById('btn-shape-square');
            const btnRect = document.getElementById('btn-shape-rect');

            if (shape === 'square') {
                state.width = 5000;
                state.height = 5000;
                btnSq.classList.add('bg-gray-600', 'text-white');
                btnSq.classList.remove('text-gray-400');
                btnRect.classList.remove('bg-gray-600', 'text-white');
                btnRect.classList.add('text-gray-400');
                previewContainer.style.aspectRatio = "1/1";
            } else {
                state.width = 8500;
                state.height = 5000;
                btnRect.classList.add('bg-gray-600', 'text-white');
                btnRect.classList.remove('text-gray-400');
                btnSq.classList.remove('bg-gray-600', 'text-white');
                btnSq.classList.add('text-gray-400');
                previewContainer.style.aspectRatio = "8500/5000";
            }
            resDisplay.innerText = `${state.width} x ${state.height}`;
            generateImage();
        }

        // --- TAB LOGIC ---
        function switchTab(tabName) {
            state.activeTab = tabName;
            
            const tabDots = document.getElementById('tab-dots');
            const tabSplits = document.getElementById('tab-splits');
            
            if (tabName === 'dots') {
                tabDots.classList.add('bg-gray-700', 'text-white', 'shadow-sm');
                tabDots.classList.remove('text-gray-400');
                tabSplits.classList.remove('bg-gray-700', 'text-white', 'shadow-sm');
                tabSplits.classList.add('text-gray-400');
            } else {
                tabSplits.classList.add('bg-gray-700', 'text-white', 'shadow-sm');
                tabSplits.classList.remove('text-gray-400');
                tabDots.classList.remove('bg-gray-700', 'text-white', 'shadow-sm');
                tabDots.classList.add('text-gray-400');
            }

            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.getElementById(`controls-${tabName}`).classList.add('active');

            generateImage();
        }

        function updateGridOptionsVisibility() {
            const el = document.getElementById('grid-style-options');
            if (state.dots.layout === 'grid') {
                el.classList.add('visible');
            } else {
                el.classList.remove('visible');
            }
        }

        function toggleInvert(tab) {
            if (tab === 'dots') {
                state.dots.invert = !state.dots.invert;
                const btn = document.getElementById('btn-invert-dots');
                const txt = document.getElementById('text-invert-dots');
                if (state.dots.invert) {
                    btn.classList.add('bg-green-700');
                    btn.classList.remove('bg-gray-600');
                    txt.innerText = "Silver Dots (Green BG)";
                } else {
                    btn.classList.remove('bg-green-700');
                    btn.classList.add('bg-gray-600');
                    txt.innerText = "Green Dots (Silver BG)";
                }
            } else {
                state.splits.invert = !state.splits.invert;
            }
            generateImage();
        }

        // --- RANDOMIZER ---
        function randomizeSettings() {
            if (state.activeTab === 'dots') {
                const layouts = ['grid', 'random'];
                setDotMode('layout', layouts[Math.floor(Math.random() * layouts.length)], true);
                const gridStyles = ['aligned', 'staggered'];
                setDotMode('gridStyle', gridStyles[Math.floor(Math.random() * gridStyles.length)], true);
                const sizes = ['uniform', 'varied'];
                setDotMode('size', sizes[Math.floor(Math.random() * sizes.length)], true);
                const newCount = Math.floor(Math.random() * 190) + 10; 
                document.getElementById('count-slider').value = newCount;
                updateCountDisplay(newCount, true);
                const newSpace = Math.floor(Math.random() * 101); 
                document.getElementById('spacing-slider').value = newSpace;
                updateSpacingDisplay(newSpace, true);
                
                // Randomly invert colors
                if (Math.random() > 0.5) toggleInvert('dots');

            } else {
                const styles = ['linear', 'diagonal', 'checker'];
                setSplitMode('style', styles[Math.floor(Math.random() * styles.length)], true);
                const orients = ['vert', 'horz'];
                setSplitMode('orient', orients[Math.floor(Math.random() * orients.length)], true);
                const divs = [2, 4, 8, 16];
                setSplitMode('divisions', divs[Math.floor(Math.random() * divs.length)], true);

                // Randomly invert colors
                if (Math.random() > 0.5) toggleInvert('splits');
            }
            generateImage();
        }

        // --- CONTROL HANDLERS (DOTS) ---
        function updateCountDisplay(val, skipGen = false) {
            document.getElementById('count-display').innerText = val;
            state.dots.count = parseInt(val);
            if (!skipGen) generateImage();
        }

        function updateSpacingDisplay(val, skipGen = false) {
            document.getElementById('spacing-display').innerText = val + "%";
            state.dots.spacing = parseInt(val);
            if (!skipGen) generateImage();
        }

        function setDotMode(key, val, skipGen = false) {
            state.dots[key] = val;
            if (key === 'layout') {
                ['grid', 'random'].forEach(opt => {
                    const btn = document.getElementById(`btn-${opt}`);
                    opt === val ? btn.classList.add('bg-gray-700', 'text-white', 'shadow-sm') : btn.classList.remove('bg-gray-700', 'text-white', 'shadow-sm');
                    opt !== val ? btn.classList.add('text-gray-400') : btn.classList.remove('text-gray-400');
                });
                updateGridOptionsVisibility();
            } else if (key === 'size') {
                ['uniform', 'varied'].forEach(opt => {
                    const btn = document.getElementById(`btn-${opt}`);
                    opt === val ? btn.classList.add('bg-gray-700', 'text-white', 'shadow-sm') : btn.classList.remove('bg-gray-700', 'text-white', 'shadow-sm');
                    opt !== val ? btn.classList.add('text-gray-400') : btn.classList.remove('text-gray-400');
                });
            } else if (key === 'gridStyle') {
                ['aligned', 'staggered'].forEach(opt => {
                    const btn = document.getElementById(`btn-grid-${opt}`);
                    opt === val ? btn.classList.add('bg-gray-700', 'text-white', 'shadow-sm') : btn.classList.remove('bg-gray-700', 'text-white', 'shadow-sm');
                    opt !== val ? btn.classList.add('text-gray-400') : btn.classList.remove('text-gray-400');
                });
            }
            if (!skipGen) generateImage();
        }

        // --- CONTROL HANDLERS (SPLITS) ---
        function setSplitMode(key, val, skipGen = false) {
            state.splits[key] = val;
            if (key === 'style') {
                ['linear', 'diagonal', 'checker'].forEach(opt => {
                    const btn = document.getElementById(`btn-style-${opt}`);
                    opt === val ? btn.classList.add('bg-gray-700', 'text-white', 'shadow-sm') : btn.classList.remove('bg-gray-700', 'text-white', 'shadow-sm');
                    opt !== val ? btn.classList.add('text-gray-400') : btn.classList.remove('text-gray-400');
                });
            } else if (key === 'orient') {
                ['vert', 'horz'].forEach(opt => {
                    const btn = document.getElementById(`btn-orient-${opt}`);
                    opt === val ? btn.classList.add('bg-gray-700', 'text-white', 'shadow-sm') : btn.classList.remove('bg-gray-700', 'text-white', 'shadow-sm');
                    opt !== val ? btn.classList.add('text-gray-400') : btn.classList.remove('text-gray-400');
                });
            } else if (key === 'divisions') {
                [2, 4, 8, 16].forEach(opt => {
                    const btn = document.getElementById(`btn-div-${opt}`);
                    if (opt === val) {
                        btn.classList.add('bg-gray-700', 'text-white', 'border', 'border-green-500/50', 'shadow-[0_0_10px_rgba(74,222,128,0.2)]');
                        btn.classList.remove('bg-gray-900', 'text-gray-400');
                    } else {
                        btn.classList.remove('bg-gray-700', 'text-white', 'border', 'border-green-500/50', 'shadow-[0_0_10px_rgba(74,222,128,0.2)]');
                        btn.classList.add('bg-gray-900', 'text-gray-400');
                    }
                });
            }
            if (!skipGen) generateImage();
        }

        // --- MATH EXPLANATION ---
        function updateMathExplanation() {
            const totalPixels = state.width * state.height;
            const targetPixels = totalPixels / 2;
            
            let html = "";

            if (state.activeTab === 'dots') {
                const count = state.dots.count;
                // Calculate average dot specs
                const avgAreaPerDot = targetPixels / count;
                const avgRadius = Math.sqrt(avgAreaPerDot / Math.PI);
                
                html = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <p class="text-gray-500">1. Total Canvas Area</p>
                            <p class="font-bold text-gray-200">${state.width.toLocaleString()} × ${state.height.toLocaleString()} = ${totalPixels.toLocaleString()} px</p>
                        </div>
                        <div>
                            <p class="text-gray-500">2. Target Coverage (50%)</p>
                            <p class="font-bold text-green-400">${targetPixels.toLocaleString()} px</p>
                        </div>
                        <div>
                            <p class="text-gray-500">3. Average Dot Area</p>
                            <p class="font-bold text-gray-200">${targetPixels.toLocaleString()} ÷ ${count} = ${Math.round(avgAreaPerDot).toLocaleString()} px</p>
                        </div>
                        <div>
                            <p class="text-gray-500">4. Calculated Radius (r)</p>
                            <p class="font-bold text-gray-200">r = √(${Math.round(avgAreaPerDot)} / π) ≈ <span class="text-purple-400">${avgRadius.toFixed(2)} px</span></p>
                        </div>
                    </div>
                `;
            } else {
                const divs = state.splits.divisions;
                const style = state.splits.style;
                const filledDivs = divs / 2;

                let logic = "";
                if (style === 'linear') logic = `The canvas is split into ${divs} equal stripes. We fill every odd stripe (${filledDivs}/${divs}).`;
                if (style === 'checker') logic = `The canvas is a grid of ${divs} equal cells. We fill alternating cells like a chessboard (${filledDivs}/${divs}).`;
                if (style === 'diagonal') logic = `The canvas is a radial pie divided into ${divs} slices. We fill alternating slices (${filledDivs}/${divs}).`;

                html = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <p class="text-gray-500">1. Total Canvas Area</p>
                            <p class="font-bold text-gray-200">${state.width.toLocaleString()} × ${state.height.toLocaleString()} = ${totalPixels.toLocaleString()} px</p>
                        </div>
                        <div>
                            <p class="text-gray-500">2. Target Coverage (50%)</p>
                            <p class="font-bold text-green-400">${targetPixels.toLocaleString()} px</p>
                        </div>
                        <div class="col-span-1 md:col-span-2 border-t border-gray-700 pt-3 mt-1">
                            <p class="text-gray-500">3. Geometric Logic (${style})</p>
                            <p class="text-gray-200">${logic}</p>
                            <p class="text-purple-400 mt-1 font-bold">Result: Exactly ${filledDivs} out of ${divs} regions filled = 50%.</p>
                        </div>
                    </div>
                `;
            }

            mathOutput.innerHTML = html;
        }

        // --- MAIN GENERATION ---
        function generateImage() {
            loader.classList.remove('hidden');
            preview.classList.add('opacity-50');
            dlBtn.disabled = true;
            genBtn.disabled = true;

            setTimeout(() => {
                try {
                    const totalPixels = state.width * state.height;
                    const halfPixels = totalPixels / 2;
                    statSilver.innerText = `Silver: 50% (${halfPixels.toLocaleString()} px)`;
                    statGreen.innerText = `Green: 50% (${halfPixels.toLocaleString()} px)`;

                    updateMathExplanation();

                    canvas.width = state.width;
                    canvas.height = state.height;

                    if (state.activeTab === 'dots') {
                        drawDots();
                    } else {
                        drawSplits();
                    }

                    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                    preview.src = dataUrl;
                    preview.onload = () => {
                        loader.classList.add('hidden');
                        preview.classList.remove('opacity-0', 'opacity-50');
                        dlBtn.disabled = false;
                        genBtn.disabled = false;
                    };
                } catch (e) {
                    console.error(e);
                    alert("Generation error. Trying again.");
                    generateImage();
                }
            }, 50);
        }

        // --- DRAWING: SPLITS ---
        function drawSplits() {
            const { style, divisions, orient, invert } = state.splits;
            const isVert = orient === 'vert';
            const w = state.width;
            const h = state.height;
            
            // Set Background and Foreground based on invert
            const bg = invert ? COLOR_GREEN : COLOR_SILVER;
            const fg = invert ? COLOR_SILVER : COLOR_GREEN;

            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = fg;

            ctx.save();
            ctx.scale(w / 5000, h / 5000);
            const LOGICAL_SIZE = 5000;

            if (style === 'linear') {
                const stripeSize = LOGICAL_SIZE / divisions;
                for (let i = 0; i < divisions; i++) {
                    if (i % 2 === 1) { 
                        if (isVert) ctx.fillRect(i * stripeSize, 0, stripeSize, LOGICAL_SIZE);
                        else ctx.fillRect(0, i * stripeSize, LOGICAL_SIZE, stripeSize);
                    }
                }
            } 
            else if (style === 'checker') {
                let cols, rows;
                if (divisions === 2) { cols = 2; rows = 1; }
                else if (divisions === 4) { cols = 2; rows = 2; }
                else if (divisions === 8) { cols = 4; rows = 2; }
                else { cols = 4; rows = 4; }

                if (!isVert) [cols, rows] = [rows, cols];

                const cw = LOGICAL_SIZE / cols;
                const ch = LOGICAL_SIZE / rows;

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if ((x + y) % 2 === 1) ctx.fillRect(x * cw, y * ch, cw, ch);
                    }
                }
            }
            else if (style === 'diagonal') {
                const cx = LOGICAL_SIZE / 2;
                const cy = LOGICAL_SIZE / 2;
                const radius = LOGICAL_SIZE * 1.5; 
                const anglePerSlice = (2 * Math.PI) / divisions;
                let rotationOffset = -Math.PI / 4;
                if (!isVert) rotationOffset += Math.PI / 2;

                for (let i = 0; i < divisions; i++) {
                    if (i % 2 === 1) {
                        const startAngle = (i * anglePerSlice) + rotationOffset;
                        const endAngle = ((i + 1) * anglePerSlice) + rotationOffset;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.arc(cx, cy, radius, startAngle, endAngle);
                        ctx.lineTo(cx, cy);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            ctx.restore();
        }

        // --- DRAWING: DOTS ---
        function drawDots() {
            const { invert } = state.dots;
            const w = state.width;
            const h = state.height;

            // Set colors
            const bg = invert ? COLOR_GREEN : COLOR_SILVER;
            const dotColor = invert ? COLOR_SILVER : COLOR_GREEN;

            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = dotColor;

            const config = state.dots;
            const targetTotalArea = (w * h) * 0.5;
            let circles = [];

            let relativeAreas = [];
            for (let i = 0; i < config.count; i++) {
                if (config.size === 'uniform') relativeAreas.push(1);
                else relativeAreas.push(0.2 + Math.random() * 0.8);
            }

            const totalRelative = relativeAreas.reduce((a, b) => a + b, 0);
            const areaScale = targetTotalArea / totalRelative;

            circles = relativeAreas.map(rel => {
                const exactArea = rel * areaScale;
                return { r: Math.sqrt(exactArea / Math.PI), x: 0, y: 0, placed: false };
            });

            if (config.layout === 'grid') placeOnGrid(circles, config.spacing, w, h);
            else placeRandomly(circles, config.spacing, w, h);

            circles.forEach(c => {
                if (c.placed) {
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function placeOnGrid(circles, spacingVal, w, h) {
            const isStaggered = state.dots.gridStyle === 'staggered';
            const jitterFactor = 1 - (spacingVal / 100);
            
            const aspect = w / h;
            const cols = Math.ceil(Math.sqrt(circles.length * aspect));
            
            const cellW = w / cols;
            const cellH = isStaggered ? (cellW * 0.866) : cellW; 

            let rows = [];
            let currentCircleIdx = 0;
            let rowIndex = 0;
            
            circles.sort(() => Math.random() - 0.5);

            while (currentCircleIdx < circles.length) {
                let capacity = cols;
                if (isStaggered && rowIndex % 2 === 1) {
                    capacity = cols - 1; 
                }
                
                const rowDots = [];
                for (let i = 0; i < capacity && currentCircleIdx < circles.length; i++) {
                    rowDots.push(circles[currentCircleIdx]);
                    currentCircleIdx++;
                }
                rows.push(rowDots);
                rowIndex++;
            }

            const totalGridHeight = rows.length * cellH;
            const startY = (h - totalGridHeight) / 2 + (cellH / 2);

            rows.forEach((rowDots, rIdx) => {
                const usedSlots = rowDots.length;
                let rowWidth = usedSlots * cellW;
                let startX = (w - rowWidth) / 2 + (cellW / 2);

                rowDots.forEach((c, cIdx) => {
                    const cx = startX + (cIdx * cellW);
                    const cy = startY + (rIdx * cellH);

                    const safeW = (cellW / 2) - c.r;
                    const safeH = (cellH / 2) - c.r;

                    let jx = 0, jy = 0;
                    if (safeW > 0) jx = (Math.random() * 2 - 1) * safeW * jitterFactor;
                    if (safeH > 0) jy = (Math.random() * 2 - 1) * safeH * jitterFactor;

                    c.x = cx + jx;
                    c.y = cy + jy;
                    c.placed = true;
                });
            });
        }

        function placeRandomly(circles, spacingVal, w, h) {
            circles.sort((a, b) => b.r - a.r);
            const bufferFactor = spacingVal / 100;
            let success = false;
            let attempts = 0;

            while (!success && attempts < 5) {
                attempts++;
                circles.forEach(c => c.placed = false);
                let currentBatchSuccess = true;

                for (let i = 0; i < circles.length; i++) {
                    const c = circles[i];
                    let placed = false;
                    let tryCount = 0;
                    const buffer = c.r * 0.25 * bufferFactor; 

                    while (!placed && tryCount < 1500) {
                        const pad = c.r;
                        const rx = pad + Math.random() * (w - 2 * pad);
                        const ry = pad + Math.random() * (h - 2 * pad);
                        let collision = false;
                        for (let j = 0; j < i; j++) {
                            const other = circles[j];
                            const dist = Math.hypot(rx - other.x, ry - other.y);
                            if (dist < c.r + other.r + buffer) {
                                collision = true;
                                break;
                            }
                        }
                        if (!collision) {
                            c.x = rx; c.y = ry; c.placed = true; placed = true;
                        }
                        tryCount++;
                    }
                    if (!placed) { currentBatchSuccess = false; break; }
                }
                if (currentBatchSuccess) success = true;
            }
        }

        function downloadImage() {
            const link = document.createElement('a');
            const type = state.activeTab === 'dots' ? 'polkadots' : state.splits.style;
            const shape = state.width === 8500 ? 'rect' : 'square';
            const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,"-");
            link.download = `50-50-${shape}-${type}-${timestamp}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

    </script>
</body>
</html>